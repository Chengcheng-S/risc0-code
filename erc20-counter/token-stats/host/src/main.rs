// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::METHOD_ELF;
use risc0_zkvm::{default_prover, ExecutorEnv};
use alloy_sol_types::SolValue;
use anyhow::{Context, Result};
use clap::Parser;
use core::{APRCommitment, CometMainInterface, CONTRACT};
use risc0_steel::{config::ETH_MAINNET_CHAIN_SPEC, ethereum::EthEvmEnv, Contract};
use risc0_zkvm::{default_executor, ExecutorEnv};
use tracing_subscriber::EnvFilter;



#[drive(Parser, Debug)]
#[command(about, long_about = None)]
struct Arg{
    /// URL of the RPC endpoint
    #[arg(short, long, env = "RPC_URL")]
    rpc_url: String,
}

fn main() ->Result<()>{
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let arg = Arg::parse();

    let mut env = EthEvmEnv::from_rpc(&arg.rpc_url,None)?;
    env.set_chain_spec(ETH_MAINNET_CHAIN_SPEC);

    let block_commitment = env.block_commitment();

    // Preflight the call to prepare the input that is required to execute the function in
    // the guest without RPC access. It also returns the result of the call.
    let mut contract = Contract::preflight(CONTRACT, &mut env);
    let utilization = contract
        .call_builder(&CometMainInterface::getUtilizationCall {})
        .call()?
        ._0;
    contract
        .call_builder(&CometMainInterface::getSupplyRateCall { utilization })
        .call()?;

    let input = env.into_input();
    println!("Running the guest with the constructed input:");
    let session_info = {
        let env = ExecutorEnv::builder()
            .write(&input)
            .unwrap()
            .build()
            .context("Failed to build exec env")?;
        let exec = default_executor();
        exec.execute(env, TOKEN_STATS_ELF)
            .context("failed to run executor")?
    };
    
    let apr_commit = APRCommitment::abi_decode(&session_info.journal.bytes, true)
        .context("failed to decode journal")?;
    assert_eq!(block_commitment, apr_commit.commitment);

    // Calculation is handling `/ 10^18 * 100` to match precision for a percentage.
    let apr = apr_commit.annualSupplyRate as f64 / 10f64.powi(16);
    println!("Proven APR calculated is: {}%", apr);

    Ok(())
}
