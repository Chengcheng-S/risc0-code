// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::BALANCE_OF_ELF;
use host::TxSender;

use alloy_primitives::Address;
use alloy_sol_types::{sol, SolCall};
use anyhow::Result;
use clap::Parser;
use risc0_ethereum_contracts::groth16::encode;
use risc0_steel::{config::ETH_SEPOLIA_CHAIN_SPEC, ethereum::EthEvmEnv, Contract, EvmBlockHeader};
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts, VerifierContext};


sol! {
    /// ERC-20 balance function signature.
    /// This must match the signature in the guest.
    interface IERC20 {
        function balanceOf(address account) external view returns (uint);
    }
}

sol!("../contracts/ICounter.sol");

#[derive(Debug, Parser)]
#[clap(author, version, about, long_about = None)]
struct Arg{

    #[clap(long)]
    chain_id: u64,

    #[clap(long, env)]
    eth_wallet_private_key: String,

    #[clap(long, env)]
    rpc_url: String,

    //  contract address
    #[clap(long)]
    contract: Address,

    //  erc20 contract address
    #[clap(long)]
    token: Address,

    /// Account address to read the balance_of on Ethereum
    #[clap(long)]
    account: Address,
}

fn main() ->Result<()>{
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    
    let args = Arg::parse();

    let mut env = EthEvmEnv::from_rpc(&args.rpc_url, None)?;
    env = env.with_chain_spec(&ETH_SEPOLIA_CHAIN_SPEC);

    let call = IERC20::balanceOfCall{account: args.account};

    let mut contract = Contract::preflight(args.token, &mut env);

    let call_result = contract.call_builder(&call).call()?;
    println!(
        "For block {} calling `{}` on {} returns: {}",
        env.header().number(),
        IERC20::balanceOfCall::SIGNATURE,
        args.token,
        call_result._0,
    );

    println!("proving...");

    let view_call_input = env.into_input()?;

    let env = ExecutorEnv::builder()
    .write(&view_call_input)?
    .write(&args.token)?
    .write(&args.account)?
    .build()?;

    let receipt = default_prover()
        .prove_with_ctx(
            env,
            &VerifierContext::default(),
            BALANCE_OF_ELF,
            &ProverOpts::groth16(),
        )?
        .receipt;
    println!("proving...done");


    let tx_sender = TxSender::new(
        args.chain_id,
         &args.rpc_url, 
         &args.eth_wallet_private_key, 
         &args.contract.to_string()
        )?;
    
    let seal = encode(receipt.inner.groth16()?.seal.clone())?;

    // Encode the function call for `ICounter.increment(journal, seal)`.
    let calldata = ICounter::incrementCall {
        journalData: receipt.journal.bytes.into(),
        seal: seal.into(),
    }
    .abi_encode();

    // Send the calldata to Ethereum.
    println!("sending tx...");
    let runtime = tokio::runtime::Runtime::new()?;
    runtime.block_on(tx_sender.send_tx(calldata))?;
    println!("sending tx...done");

    Ok(())
}
